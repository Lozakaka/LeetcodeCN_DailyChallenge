### Solution 1 - LogTrick 對數法
```java
class Solution {
    public int minimumDifference(int[] nums, int k) {
        int n = nums.length;
        int ans = Integer.MAX_VALUE;
        for(int i = 0; i < n; i++){
            int x = nums[i];
            ans = Math.min(ans, Math.abs(x - k));
            for(int j = i - 1; j >= 0; j--){
                if((nums[j] | x) == nums[j])
                    break;
                nums[j] |= x;
                ans = Math.min(ans, Math.abs(nums[j] - k));
            }
        }
        return ans;
    }
}
```
* time compelxity: $(n log U), U = log(10 ^ 9) ~= 30$
* space complexity: $O(1)$

### Solution 2 - slide window with bitCount array
```java
class Solution {
    public int minimumDifference(int[] nums, int k) {
        int ans = Integer.MAX_VALUE;
        int n = nums.length;
        int left = 0;
        int[] bitCount = new int[32];
        int orRes = 0;
        for(int right = 0; right < n; right++){
            int x = nums[right];
            for(int i = 0; i < 32; i++){
                if((x >> i & 1) == 1){
                    bitCount[i]++;
                }
            }
            orRes |= x;
            ans = Math.min(ans, Math.abs(k - orRes));
            while(left < right && orRes > k){
                int dele = nums[left];
                for(int i = 0; i < 32; i++){
                    if((dele >> i & 1) == 1){
                        bitCount[i]--;
                        if(bitCount[i] == 0){
                            orRes ^= 1 << i;
                        }
                    }
                }
                ans = Math.min(ans, Math.abs(k - orRes));
                left++;
            }
        }
        return ans;
    }
}
```
* time compelxity: $O(32n) = O(n)$
* space complexity: $O(32) = O(1)$

### Solution 3 - slide window
```java
class Solution {
    public int minimumDifference(int[] nums, int k) {
        int n = nums.length;
        int left = 0;
        int bottom = 0;
        int ans = Integer.MAX_VALUE;
        int orRes = 0;

        for(int right = 0; right < n; right++){
            orRes |= nums[right];
            while(left <= right && (nums[left] | orRes) > k){
                ans = Math.min(ans, (nums[left] | orRes) - k);
                left++;
                if(left > bottom){
                    for(int i = right - 1; i >= left; i--){
                        nums[i] |= nums[i + 1];
                    }
                    bottom = right;
                    orRes = 0;
                }
            }
            if(left <= right){
                ans = Math.min(k - (nums[left] | orRes), ans);
            }
        }
        return ans;
    }
}
```
* time compelxity: $O(n)$
* space complexity: $O(1)$